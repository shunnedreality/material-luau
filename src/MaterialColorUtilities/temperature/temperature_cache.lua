-- ROBLOX NOTE: no upstream
--[[*
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ]]
local Packages = script.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Boolean = LuauPolyfill.Boolean
local Map = LuauPolyfill.Map
local Math = LuauPolyfill.Math
type Array<T> = LuauPolyfill.Array<T>
type Map<T, U> = LuauPolyfill.Map<T, U>
local exports = {}
-- This file is automatically generated. Do not modify it.
local Hct = require(script.Parent.Parent.hct["hct"]).Hct
local colorUtils = require(script.Parent.Parent.utils["color_utils"])
local mathUtils = require(script.Parent.Parent.utils["math_utils"])
--[[*
 * Design utilities using color temperature theory.
 *
 * Analogous colors, complementary color, and cache to efficiently, lazily,
 * generate data for calculations when needed.
 ]]
export type TemperatureCache = {
	input: Hct,
	hctsByTempCache: Array<Hct>,
	hctsByHueCache: Array<Hct>,
	tempsByHctCache: any,
	inputRelativeTemperatureCache: number,
	complementCache: Hct | nil,--[[ ROBLOX CHECK: verify if `null` wasn't used differently than `undefined` ]]
	hctsByTemp: (self: TemperatureCache) -> Array<Hct>,
	warmest: (self: TemperatureCache) -> Hct,
	coldest: (self: TemperatureCache) -> Hct,
	--[[*
   * A set of colors with differing hues, equidistant in temperature.
   *
   * In art, this is usually described as a set of 5 colors on a color wheel
   * divided into 12 sections. This method allows provision of either of those
   * values.
   *
   * Behavior is undefined when [count] or [divisions] is 0.
   * When divisions < count, colors repeat.
   *
   * [count] The number of colors to return, includes the input color.
   * [divisions] The number of divisions on the color wheel.
   ]]
	analogous: (self: TemperatureCache, count_: number?, divisions_: number?) -> Array<Hct>,
	--[[*
   * A color that complements the input color aesthetically.
   *
   * In art, this is usually described as being across the color wheel.
   * History of this shows intent as a color that is just as cool-warm as the
   * input color is warm-cool.
   ]]
	complement: (self: TemperatureCache) -> Hct,
	--[[*
   * Temperature relative to all colors with the same chroma and tone.
   * Value on a scale from 0 to 1.
   ]]
	relativeTemperature: (self: TemperatureCache, hct: Hct) -> number,
	--[[* Relative temperature of the input color. See [relativeTemperature]. ]]
	inputRelativeTemperature: (self: TemperatureCache) -> number,
	--[[* A Map with keys of HCTs in [hctsByTemp], values of raw temperature. ]]
	tempsByHct: (self: TemperatureCache) -> Map<Hct, number>,
	--[[*
   * HCTs for all hues, with the same chroma/tone as the input.
   * Sorted ascending, hue 0 to 360.
   ]]
	hctsByHue: (self: TemperatureCache) -> Array<Hct>,
	--[[* Determines if an angle is between two other angles, rotating clockwise. ]]
}
type TemperatureCache_statics = { new: (input: Hct) -> TemperatureCache }
local TemperatureCache = {} :: TemperatureCache & TemperatureCache_statics;
(TemperatureCache :: any).__index = TemperatureCache
function TemperatureCache.new(input: Hct): TemperatureCache
	local self = setmetatable({}, TemperatureCache)
	self.input = input
	self.hctsByTempCache = {}
	self.hctsByHueCache = {}
	self.tempsByHctCache = Map.new()
	self.inputRelativeTemperatureCache = -1.0
	self.complementCache = nil
	return (self :: any) :: TemperatureCache
end
function TemperatureCache:hctsByTemp(): Array<Hct>
	if
		self.hctsByTempCache.length
		> 0 --[[ ROBLOX CHECK: operator '>' works only if either both arguments are strings or both are a number ]]
	then
		return self.hctsByTempCache
	end
	local hcts = Array.concat(self.hctsByHue, { self.input }) --[[ ROBLOX CHECK: check if 'this.hctsByHue' is an Array ]]
	local temperaturesByHct = self.tempsByHct
	Array.sort(hcts, function(a, b)
		return temperaturesByHct:get(a) :: any - temperaturesByHct:get(b) :: any
	end) --[[ ROBLOX CHECK: check if 'hcts' is an Array ]]
	self.hctsByTempCache = hcts
	return hcts
end
function TemperatureCache:warmest(): Hct
	return self.hctsByTemp[tostring(self.hctsByTemp.length - 1)]
end
function TemperatureCache:coldest(): Hct
	return self.hctsByTemp[
		1 --[[ ROBLOX adaptation: added 1 to array index ]]
	]
end
function TemperatureCache:analogous(count_: number?, divisions_: number?): Array<Hct>
	local count: number = if count_ ~= nil then count_ else 5
	local divisions: number = if divisions_ ~= nil then divisions_ else 12
	local startHue = Math.round(self.input.hue) --[[ ROBLOX NOTE: Math.round is currently not supported by the Luau Math polyfill, please add your own implementation or file a ticket on the same ]]
	local startHct = self.hctsByHue[tostring(startHue)]
	local lastTemp = self:relativeTemperature(startHct)
	local allColors = { startHct }
	local absoluteTotalTempDelta = 0.0
	do
		local i = 0
		while
			i
			< 360 --[[ ROBLOX CHECK: operator '<' works only if either both arguments are strings or both are a number ]]
		do
			local hue = mathUtils:sanitizeDegreesInt(startHue + i)
			local hct = self.hctsByHue[tostring(hue)]
			local temp = self:relativeTemperature(hct)
			local tempDelta = math.abs(temp - lastTemp)
			lastTemp = temp
			absoluteTotalTempDelta += tempDelta
			i += 1
		end
	end
	local hueAddend = 1
	local tempStep = absoluteTotalTempDelta / divisions
	local totalTempDelta = 0.0
	lastTemp = self:relativeTemperature(startHct)
	while
		allColors.length
		< divisions --[[ ROBLOX CHECK: operator '<' works only if either both arguments are strings or both are a number ]]
	do
		local hue = mathUtils:sanitizeDegreesInt(startHue + hueAddend)
		local hct = self.hctsByHue[tostring(hue)]
		local temp = self:relativeTemperature(hct)
		local tempDelta = math.abs(temp - lastTemp)
		totalTempDelta += tempDelta
		local desiredTotalTempDeltaForIndex = allColors.length * tempStep
		local indexSatisfied = totalTempDelta >= desiredTotalTempDeltaForIndex --[[ ROBLOX CHECK: operator '>=' works only if either both arguments are strings or both are a number ]]
		local indexAddend = 1
		-- Keep adding this hue to the answers until its temperature is
		-- insufficient. This ensures consistent behavior when there aren't
		-- [divisions] discrete steps between 0 and 360 in hue with [tempStep]
		-- delta in temperature between them.
		--
		-- For example, white and black have no analogues: there are no other
		-- colors at T100/T0. Therefore, they should just be added to the array
		-- as answers.
		while
			Boolean.toJSBoolean(if Boolean.toJSBoolean(indexSatisfied)
				then allColors.length
					< divisions --[[ ROBLOX CHECK: operator '<' works only if either both arguments are strings or both are a number ]]
				else indexSatisfied)
		do
			table.insert(allColors, hct) --[[ ROBLOX CHECK: check if 'allColors' is an Array ]]
			local desiredTotalTempDeltaForIndex = (allColors.length + indexAddend) * tempStep
			indexSatisfied = totalTempDelta >= desiredTotalTempDeltaForIndex --[[ ROBLOX CHECK: operator '>=' works only if either both arguments are strings or both are a number ]]
			indexAddend += 1
		end
		lastTemp = temp
		hueAddend += 1
		if
			hueAddend
			> 360 --[[ ROBLOX CHECK: operator '>' works only if either both arguments are strings or both are a number ]]
		then
			while
				allColors.length
				< divisions --[[ ROBLOX CHECK: operator '<' works only if either both arguments are strings or both are a number ]]
			do
				table.insert(allColors, hct) --[[ ROBLOX CHECK: check if 'allColors' is an Array ]]
			end
			break
		end
	end
	local answers = { self.input }
	-- First, generate analogues from rotating counter-clockwise.
	local increaseHueCount = math.floor((count - 1) / 2.0)
	do
		local i = 1
		while
			i
			< increaseHueCount + 1 --[[ ROBLOX CHECK: operator '<' works only if either both arguments are strings or both are a number ]]
		do
			local index = 0 - i
			while
				index
				< 0 --[[ ROBLOX CHECK: operator '<' works only if either both arguments are strings or both are a number ]]
			do
				index = allColors.length + index
			end
			if
				index
				>= allColors.length --[[ ROBLOX CHECK: operator '>=' works only if either both arguments are strings or both are a number ]]
			then
				index = index % allColors.length
			end
			Array.splice(answers, 0, 0, allColors[tostring(index)]) --[[ ROBLOX CHECK: check if 'answers' is an Array ]]
			i += 1
		end
	end
	-- Second, generate analogues from rotating clockwise.
	local decreaseHueCount = count - increaseHueCount - 1
	do
		local i = 1
		while
			i
			< decreaseHueCount + 1 --[[ ROBLOX CHECK: operator '<' works only if either both arguments are strings or both are a number ]]
		do
			local index = i
			while
				index
				< 0 --[[ ROBLOX CHECK: operator '<' works only if either both arguments are strings or both are a number ]]
			do
				index = allColors.length + index
			end
			if
				index
				>= allColors.length --[[ ROBLOX CHECK: operator '>=' works only if either both arguments are strings or both are a number ]]
			then
				index = index % allColors.length
			end
			table.insert(answers, allColors[tostring(index)]) --[[ ROBLOX CHECK: check if 'answers' is an Array ]]
			i += 1
		end
	end
	return answers
end
function TemperatureCache:complement(): Hct
	if
		self.complementCache ~= nil --[[ ROBLOX CHECK: loose inequality used upstream ]]
	then
		return self.complementCache
	end
	local coldestHue = self.coldest.hue
	local coldestTemp = self.tempsByHct:get(self.coldest) :: any
	local warmestHue = self.warmest.hue
	local warmestTemp = self.tempsByHct:get(self.warmest) :: any
	local range = warmestTemp - coldestTemp
	local startHueIsColdestToWarmest =
		TemperatureCache:isBetween(self.input.hue, coldestHue, warmestHue)
	local startHue = if Boolean.toJSBoolean(startHueIsColdestToWarmest)
		then warmestHue
		else coldestHue
	local endHue = if Boolean.toJSBoolean(startHueIsColdestToWarmest)
		then coldestHue
		else warmestHue
	local directionOfRotation = 1.0
	local smallestError = 1000.0
	local answer = self.hctsByHue[
		tostring(
			Math.round(self.input.hue) --[[ ROBLOX NOTE: Math.round is currently not supported by the Luau Math polyfill, please add your own implementation or file a ticket on the same ]]
		)
	]
	local complementRelativeTemp = 1.0 - self.inputRelativeTemperature
	-- Find the color in the other section, closest to the inverse percentile
	-- of the input color. This is the complement.
	do
		local hueAddend = 0.0
		while
			hueAddend
			<= 360.0 --[[ ROBLOX CHECK: operator '<=' works only if either both arguments are strings or both are a number ]]
		do
			local hue = mathUtils:sanitizeDegreesDouble(startHue + directionOfRotation * hueAddend)
			if not Boolean.toJSBoolean(TemperatureCache:isBetween(hue, startHue, endHue)) then
				hueAddend += 1.0
				continue
			end
			local possibleAnswer = self.hctsByHue[
				tostring(
					Math.round(hue) --[[ ROBLOX NOTE: Math.round is currently not supported by the Luau Math polyfill, please add your own implementation or file a ticket on the same ]]
				)
			]
			local relativeTemp = (self.tempsByHct:get(possibleAnswer) :: any - coldestTemp) / range
			local error_ = math.abs(complementRelativeTemp - relativeTemp)
			if
				error_
				< smallestError --[[ ROBLOX CHECK: operator '<' works only if either both arguments are strings or both are a number ]]
			then
				smallestError = error_
				answer = possibleAnswer
			end
			hueAddend += 1.0
		end
	end
	self.complementCache = answer
	return self.complementCache
end
function TemperatureCache:relativeTemperature(hct: Hct): number
	local range = self.tempsByHct:get(self.warmest) :: any
		- self.tempsByHct:get(self.coldest) :: any
	local differenceFromColdest = self.tempsByHct:get(hct) :: any
		- self.tempsByHct:get(self.coldest) :: any
	-- Handle when there's no difference in temperature between warmest and
	-- coldest: for example, at T100, only one color is available, white.
	if range == 0.0 then
		return 0.5
	end
	return differenceFromColdest / range
end
function TemperatureCache:inputRelativeTemperature(): number
	if
		self.inputRelativeTemperatureCache
		>= 0.0 --[[ ROBLOX CHECK: operator '>=' works only if either both arguments are strings or both are a number ]]
	then
		return self.inputRelativeTemperatureCache
	end
	self.inputRelativeTemperatureCache = self:relativeTemperature(self.input)
	return self.inputRelativeTemperatureCache
end
function TemperatureCache:tempsByHct(): Map<Hct, number>
	if
		self.tempsByHctCache.size
		> 0 --[[ ROBLOX CHECK: operator '>' works only if either both arguments are strings or both are a number ]]
	then
		return self.tempsByHctCache
	end
	local allHcts = Array.concat(self.hctsByHue, { self.input }) --[[ ROBLOX CHECK: check if 'this.hctsByHue' is an Array ]]
	local temperaturesByHct = Map.new()
	for _, e in allHcts do
		temperaturesByHct:set(e, TemperatureCache:rawTemperature(e))
	end
	self.tempsByHctCache = temperaturesByHct
	return temperaturesByHct
end
function TemperatureCache:hctsByHue(): Array<Hct>
	if
		self.hctsByHueCache.length
		> 0 --[[ ROBLOX CHECK: operator '>' works only if either both arguments are strings or both are a number ]]
	then
		return self.hctsByHueCache
	end
	local hcts: Array<Hct> = {}
	do
		local hue = 0.0
		while
			hue
			<= 360.0 --[[ ROBLOX CHECK: operator '<=' works only if either both arguments are strings or both are a number ]]
		do
			local colorAtHue = Array.from(Hct, hue, self.input.chroma, self.input.tone) --[[ ROBLOX CHECK: check if 'Hct' is an Array ]]
			table.insert(hcts, colorAtHue) --[[ ROBLOX CHECK: check if 'hcts' is an Array ]]
			hue += 1.0
		end
	end
	self.hctsByHueCache = hcts
	return self.hctsByHueCache
end
function TemperatureCache.isBetween(angle: number, a: number, b: number): boolean
	if
		a
		< b --[[ ROBLOX CHECK: operator '<' works only if either both arguments are strings or both are a number ]]
	then
		return a <= angle --[[ ROBLOX CHECK: operator '<=' works only if either both arguments are strings or both are a number ]]
			and angle <= b --[[ ROBLOX CHECK: operator '<=' works only if either both arguments are strings or both are a number ]]
	end
	return a <= angle --[[ ROBLOX CHECK: operator '<=' works only if either both arguments are strings or both are a number ]]
		or angle <= b --[[ ROBLOX CHECK: operator '<=' works only if either both arguments are strings or both are a number ]]
end
function TemperatureCache.rawTemperature(color: Hct): number
	local lab = colorUtils:labFromArgb(color:toInt())
	local hue = mathUtils:sanitizeDegreesDouble(math.atan2(
		lab[
			3 --[[ ROBLOX adaptation: added 1 to array index ]]
		],
		lab[
			2 --[[ ROBLOX adaptation: added 1 to array index ]]
		]
	) * 180.0 / math.pi)
	local chroma = math.sqrt(lab[
		2 --[[ ROBLOX adaptation: added 1 to array index ]]
	] * lab[
		2 --[[ ROBLOX adaptation: added 1 to array index ]]
	] + lab[
		3 --[[ ROBLOX adaptation: added 1 to array index ]]
	] * lab[
		3 --[[ ROBLOX adaptation: added 1 to array index ]]
	])
	local temperature = -0.5
		+ 0.02
			* math.pow(chroma, 1.07)
			* math.cos(mathUtils:sanitizeDegreesDouble(hue - 50.0) * math.pi / 180.0)
	return temperature
end
exports.TemperatureCache = TemperatureCache
return exports
