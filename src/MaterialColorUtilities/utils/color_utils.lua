-- ROBLOX NOTE: no upstream
--[[*
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ]]
local Packages = script.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Math = LuauPolyfill.Math
type Array<T> = LuauPolyfill.Array<T>
local exports = {}
-- This file is automatically generated. Do not modify it.
local mathUtils = require(script.Parent["math_utils"])
--[[*
 * Color science utilities.
 *
 * Utility methods for color science constants and color space
 * conversions that aren't HCT or CAM16.
 ]]
local SRGB_TO_XYZ = {
	{ 0.41233895, 0.35762064, 0.18051042 },
	{ 0.2126, 0.7152, 0.0722 },
	{ 0.01932141, 0.11916382, 0.95034478 },
}
local XYZ_TO_SRGB = {
	{ 3.2413774792388685, -1.5376652402851851, -0.49885366846268053 },
	{ -0.9691452513005321, 1.8758853451067872, 0.04156585616912061 },
	{ 0.05562093689691305, -0.20395524564742123, 1.0571799111220335 },
}
local WHITE_POINT_D65 = { 95.047, 100.0, 108.883 }
--[[*
 * Converts a color from RGB components to ARGB format.
 ]]
function argbFromRgb(red: number, green: number, blue: number): number
	return bit32.rshift(
		bit32.bor(
			bit32.bor(
				bit32.bor(
					bit32.lshift(255, 24), --[[ ROBLOX CHECK: `bit32.lshift` clamps arguments and result to [0,2^32 - 1] ]]
					bit32.lshift(
						bit32.band(red, 255), --[[ ROBLOX CHECK: `bit32.band` clamps arguments and result to [0,2^32 - 1] ]]
						16
					) --[[ ROBLOX CHECK: `bit32.lshift` clamps arguments and result to [0,2^32 - 1] ]]
				), --[[ ROBLOX CHECK: `bit32.bor` clamps arguments and result to [0,2^32 - 1] ]]
				bit32.lshift(
					bit32.band(green, 255), --[[ ROBLOX CHECK: `bit32.band` clamps arguments and result to [0,2^32 - 1] ]]
					8
				) --[[ ROBLOX CHECK: `bit32.lshift` clamps arguments and result to [0,2^32 - 1] ]]
			), --[[ ROBLOX CHECK: `bit32.bor` clamps arguments and result to [0,2^32 - 1] ]]
			bit32.band(blue, 255) --[[ ROBLOX CHECK: `bit32.band` clamps arguments and result to [0,2^32 - 1] ]]
		), --[[ ROBLOX CHECK: `bit32.bor` clamps arguments and result to [0,2^32 - 1] ]]
		0
	) --[[ ROBLOX CHECK: `bit32.rshift` clamps arguments and result to [0,2^32 - 1] ]]
end
exports.argbFromRgb = argbFromRgb
--[[*
 * Converts a color from linear RGB components to ARGB format.
 ]]
function argbFromLinrgb(linrgb: Array<number>): number
	local r = delinearized(linrgb[
		1 --[[ ROBLOX adaptation: added 1 to array index ]]
	])
	local g = delinearized(linrgb[
		2 --[[ ROBLOX adaptation: added 1 to array index ]]
	])
	local b = delinearized(linrgb[
		3 --[[ ROBLOX adaptation: added 1 to array index ]]
	])
	return argbFromRgb(r, g, b)
end
exports.argbFromLinrgb = argbFromLinrgb
--[[*
 * Returns the alpha component of a color in ARGB format.
 ]]
function alphaFromArgb(argb: number): number
	return bit32.band(
		bit32.arshift(argb, 24), --[[ ROBLOX CHECK: `bit32.arshift` clamps arguments and result to [0,2^32 - 1] ]]
		255
	) --[[ ROBLOX CHECK: `bit32.band` clamps arguments and result to [0,2^32 - 1] ]]
end
exports.alphaFromArgb = alphaFromArgb
--[[*
 * Returns the red component of a color in ARGB format.
 ]]
function redFromArgb(argb: number): number
	return bit32.band(
		bit32.arshift(argb, 16), --[[ ROBLOX CHECK: `bit32.arshift` clamps arguments and result to [0,2^32 - 1] ]]
		255
	) --[[ ROBLOX CHECK: `bit32.band` clamps arguments and result to [0,2^32 - 1] ]]
end
exports.redFromArgb = redFromArgb
--[[*
 * Returns the green component of a color in ARGB format.
 ]]
function greenFromArgb(argb: number): number
	return bit32.band(
		bit32.arshift(argb, 8), --[[ ROBLOX CHECK: `bit32.arshift` clamps arguments and result to [0,2^32 - 1] ]]
		255
	) --[[ ROBLOX CHECK: `bit32.band` clamps arguments and result to [0,2^32 - 1] ]]
end
exports.greenFromArgb = greenFromArgb
--[[*
 * Returns the blue component of a color in ARGB format.
 ]]
function blueFromArgb(argb: number): number
	return bit32.band(argb, 255) --[[ ROBLOX CHECK: `bit32.band` clamps arguments and result to [0,2^32 - 1] ]]
end
exports.blueFromArgb = blueFromArgb
--[[*
 * Returns whether a color in ARGB format is opaque.
 ]]
function isOpaque(argb: number): boolean
	return alphaFromArgb(argb) >= 255 --[[ ROBLOX CHECK: operator '>=' works only if either both arguments are strings or both are a number ]]
end
exports.isOpaque = isOpaque
--[[*
 * Converts a color from ARGB to XYZ.
 ]]
function argbFromXyz(x: number, y: number, z: number): number
	local matrix = XYZ_TO_SRGB
	local linearR = matrix[
		1 --[[ ROBLOX adaptation: added 1 to array index ]]
	][
		1 --[[ ROBLOX adaptation: added 1 to array index ]]
	]
			* x
		+ matrix[
				1 --[[ ROBLOX adaptation: added 1 to array index ]]
			][
				2 --[[ ROBLOX adaptation: added 1 to array index ]]
			]
			* y
		+ matrix[
				1 --[[ ROBLOX adaptation: added 1 to array index ]]
			][
				3 --[[ ROBLOX adaptation: added 1 to array index ]]
			]
			* z
	local linearG = matrix[
		2 --[[ ROBLOX adaptation: added 1 to array index ]]
	][
		1 --[[ ROBLOX adaptation: added 1 to array index ]]
	]
			* x
		+ matrix[
				2 --[[ ROBLOX adaptation: added 1 to array index ]]
			][
				2 --[[ ROBLOX adaptation: added 1 to array index ]]
			]
			* y
		+ matrix[
				2 --[[ ROBLOX adaptation: added 1 to array index ]]
			][
				3 --[[ ROBLOX adaptation: added 1 to array index ]]
			]
			* z
	local linearB = matrix[
		3 --[[ ROBLOX adaptation: added 1 to array index ]]
	][
		1 --[[ ROBLOX adaptation: added 1 to array index ]]
	]
			* x
		+ matrix[
				3 --[[ ROBLOX adaptation: added 1 to array index ]]
			][
				2 --[[ ROBLOX adaptation: added 1 to array index ]]
			]
			* y
		+ matrix[
				3 --[[ ROBLOX adaptation: added 1 to array index ]]
			][
				3 --[[ ROBLOX adaptation: added 1 to array index ]]
			]
			* z
	local r = delinearized(linearR)
	local g = delinearized(linearG)
	local b = delinearized(linearB)
	return argbFromRgb(r, g, b)
end
exports.argbFromXyz = argbFromXyz
--[[*
 * Converts a color from XYZ to ARGB.
 ]]
function xyzFromArgb(argb: number): Array<number>
	local r = linearized(redFromArgb(argb))
	local g = linearized(greenFromArgb(argb))
	local b = linearized(blueFromArgb(argb))
	return mathUtils.matrixMultiply({ r, g, b }, SRGB_TO_XYZ)
end
exports.xyzFromArgb = xyzFromArgb
--[[*
 * Converts a color represented in Lab color space into an ARGB
 * integer.
 ]]
function argbFromLab(l: number, a: number, b: number): number
	local whitePoint = WHITE_POINT_D65
	local fy = (l + 16.0) / 116.0
	local fx = a / 500.0 + fy
	local fz = fy - b / 200.0
	local xNormalized = labInvf(fx)
	local yNormalized = labInvf(fy)
	local zNormalized = labInvf(fz)
	local x = xNormalized
		* whitePoint[
			1 --[[ ROBLOX adaptation: added 1 to array index ]]
		]
	local y = yNormalized
		* whitePoint[
			2 --[[ ROBLOX adaptation: added 1 to array index ]]
		]
	local z = zNormalized
		* whitePoint[
			3 --[[ ROBLOX adaptation: added 1 to array index ]]
		]
	return argbFromXyz(x, y, z)
end
exports.argbFromLab = argbFromLab
--[[*
 * Converts a color from ARGB representation to L*a*b*
 * representation.
 *
 * @param argb the ARGB representation of a color
 * @return a Lab object representing the color
 ]]
function labFromArgb(argb: number): Array<number>
	local linearR = linearized(redFromArgb(argb))
	local linearG = linearized(greenFromArgb(argb))
	local linearB = linearized(blueFromArgb(argb))
	local matrix = SRGB_TO_XYZ
	local x = matrix[
		1 --[[ ROBLOX adaptation: added 1 to array index ]]
	][
		1 --[[ ROBLOX adaptation: added 1 to array index ]]
	]
			* linearR
		+ matrix[
				1 --[[ ROBLOX adaptation: added 1 to array index ]]
			][
				2 --[[ ROBLOX adaptation: added 1 to array index ]]
			]
			* linearG
		+ matrix[
				1 --[[ ROBLOX adaptation: added 1 to array index ]]
			][
				3 --[[ ROBLOX adaptation: added 1 to array index ]]
			]
			* linearB
	local y = matrix[
		2 --[[ ROBLOX adaptation: added 1 to array index ]]
	][
		1 --[[ ROBLOX adaptation: added 1 to array index ]]
	]
			* linearR
		+ matrix[
				2 --[[ ROBLOX adaptation: added 1 to array index ]]
			][
				2 --[[ ROBLOX adaptation: added 1 to array index ]]
			]
			* linearG
		+ matrix[
				2 --[[ ROBLOX adaptation: added 1 to array index ]]
			][
				3 --[[ ROBLOX adaptation: added 1 to array index ]]
			]
			* linearB
	local z = matrix[
		3 --[[ ROBLOX adaptation: added 1 to array index ]]
	][
		1 --[[ ROBLOX adaptation: added 1 to array index ]]
	]
			* linearR
		+ matrix[
				3 --[[ ROBLOX adaptation: added 1 to array index ]]
			][
				2 --[[ ROBLOX adaptation: added 1 to array index ]]
			]
			* linearG
		+ matrix[
				3 --[[ ROBLOX adaptation: added 1 to array index ]]
			][
				3 --[[ ROBLOX adaptation: added 1 to array index ]]
			]
			* linearB
	local whitePoint = WHITE_POINT_D65
	local xNormalized = x
		/ whitePoint[
			1 --[[ ROBLOX adaptation: added 1 to array index ]]
		]
	local yNormalized = y
		/ whitePoint[
			2 --[[ ROBLOX adaptation: added 1 to array index ]]
		]
	local zNormalized = z
		/ whitePoint[
			3 --[[ ROBLOX adaptation: added 1 to array index ]]
		]
	local fx = labF(xNormalized)
	local fy = labF(yNormalized)
	local fz = labF(zNormalized)
	local l = 116.0 * fy - 16
	local a = 500.0 * (fx - fy)
	local b = 200.0 * (fy - fz)
	return { l, a, b }
end
exports.labFromArgb = labFromArgb
--[[*
 * Converts an L* value to an ARGB representation.
 *
 * @param lstar L* in L*a*b*
 * @return ARGB representation of grayscale color with lightness
 * matching L*
 ]]
function argbFromLstar(lstar: number): number
	local y = yFromLstar(lstar)
	local component = delinearized(y)
	return argbFromRgb(component, component, component)
end
exports.argbFromLstar = argbFromLstar
--[[*
 * Computes the L* value of a color in ARGB representation.
 *
 * @param argb ARGB representation of a color
 * @return L*, from L*a*b*, coordinate of the color
 ]]
function lstarFromArgb(argb: number): number
	local y = xyzFromArgb(argb)[
		2 --[[ ROBLOX adaptation: added 1 to array index ]]
	]
	return 116.0 * labF(y / 100.0) - 16.0
end
exports.lstarFromArgb = lstarFromArgb
--[[*
 * Converts an L* value to a Y value.
 *
 * L* in L*a*b* and Y in XYZ measure the same quantity, luminance.
 *
 * L* measures perceptual luminance, a linear scale. Y in XYZ
 * measures relative luminance, a logarithmic scale.
 *
 * @param lstar L* in L*a*b*
 * @return Y in XYZ
 ]]
function yFromLstar(lstar: number): number
	return 100.0 * labInvf((lstar + 16.0) / 116.0)
end
exports.yFromLstar = yFromLstar
--[[*
 * Converts a Y value to an L* value.
 *
 * L* in L*a*b* and Y in XYZ measure the same quantity, luminance.
 *
 * L* measures perceptual luminance, a linear scale. Y in XYZ
 * measures relative luminance, a logarithmic scale.
 *
 * @param y Y in XYZ
 * @return L* in L*a*b*
 ]]
function lstarFromY(y: number): number
	return labF(y / 100.0) * 116.0 - 16.0
end
exports.lstarFromY = lstarFromY
--[[*
 * Linearizes an RGB component.
 *
 * @param rgbComponent 0 <= rgb_component <= 255, represents R/G/B
 * channel
 * @return 0.0 <= output <= 100.0, color channel converted to
 * linear RGB space
 ]]
function linearized(rgbComponent: number): number
	local normalized = rgbComponent / 255.0
	if
		normalized
		<= 0.040449936 --[[ ROBLOX CHECK: operator '<=' works only if either both arguments are strings or both are a number ]]
	then
		return normalized / 12.92 * 100.0
	else
		return math.pow((normalized + 0.055) / 1.055, 2.4) * 100.0
	end
end
exports.linearized = linearized
--[[*
 * Delinearizes an RGB component.
 *
 * @param rgbComponent 0.0 <= rgb_component <= 100.0, represents
 * linear R/G/B channel
 * @return 0 <= output <= 255, color channel converted to regular
 * RGB space
 ]]
function delinearized(rgbComponent: number): number
	local normalized = rgbComponent / 100.0
	local delinearized = 0.0
	if
		normalized
		<= 0.0031308 --[[ ROBLOX CHECK: operator '<=' works only if either both arguments are strings or both are a number ]]
	then
		delinearized = normalized * 12.92
	else
		delinearized = 1.055 * math.pow(normalized, 1.0 / 2.4) - 0.055
	end
	return mathUtils.clampInt(
		0,
		255,
		math.round(delinearized * 255.0) --[[ ROBLOX NOTE: Math.round is currently not supported by the Luau Math polyfill, please add your own implementation or file a ticket on the same ]]
	)
end
exports.delinearized = delinearized
--[[*
 * Returns the standard white point; white on a sunny day.
 *
 * @return The white point
 ]]
function whitePointD65(): Array<number>
	return WHITE_POINT_D65
end
exports.whitePointD65 = whitePointD65
function labF(t: number): number
	local e = 216.0 / 24389.0
	local kappa = 24389.0 / 27.0
	if
		t
		> e --[[ ROBLOX CHECK: operator '>' works only if either both arguments are strings or both are a number ]]
	then
		return math.pow(t, 1.0 / 3.0)
	else
		return (kappa * t + 16) / 116
	end
end
function labInvf(ft: number): number
	local e = 216.0 / 24389.0
	local kappa = 24389.0 / 27.0
	local ft3 = ft * ft * ft
	if
		ft3
		> e --[[ ROBLOX CHECK: operator '>' works only if either both arguments are strings or both are a number ]]
	then
		return ft3
	else
		return (116 * ft - 16) / kappa
	end
end
return exports
